"""Interface to matplotlib plot server

Basic usage is 
  import ezplot.plotclient
  p = ezplot.plotclient.Plotter()
  p.plot([1,2,3],[4,-2,3])

But you can also access Plotter directly from the top level 
ezplot namespace.
"""
from ezplot import common

import pickle
import xmlrpclib
import socket
#import SOAPpy

def report_exception(msgprefix=None):
    """Format an exception nicely and output it to stdout"""
    import sys,traceback
    def formatExceptionInfo(maxTBlevel=5):
        cla, exc, trbk = sys.exc_info()
        excName = cla.__name__
        try:
            excArgs = exc.__dict__["args"]
        except KeyError:
            excArgs = "<no args>"
        excTb = traceback.format_tb(trbk, maxTBlevel)
        return (excName, excArgs, excTb)

    exinfo = formatExceptionInfo()
    if msgprefix is None: msgprefix = "Exception"
    print msgprefix, ":", exinfo[0], ":", exinfo[1]
    print "traceback:\n", exinfo[2]

    

def spawn_plotter():
    """Start up the plotter serer process"""
    import subprocess
    import sys,os

    prog = """import ezplot.plotserver; ezplot.plotserver.start();"""
    
    args = [sys.executable, '-c', prog]
    env = os.environ.copy()
    env['PYTHONPATH']= ';'.join(sys.path)

    proc = subprocess.Popen(args,env=env)

    return proc.pid

def get_default_plotter_service_url():
    """Return the default service id for the plotter server."""
    url = 'http://localhost:%s' % str(common.defaultPort)
    return url

class Plotter:
    """
    Main interface to the remote plot server.

    Methods on this class that require a server will automatically launch a server
    if none has been created yet.  So for most cases, the basic usage is just
    as follows.

    Basic usage:

       import ezplot
       p = ezplot.Plotter()
       p.plot([1,2,3],[4,-2,3])
    """
    def __init__(self, url=None):
        if url is None:
            url = get_default_plotter_service_url()

        self.service_url = url
        self.server_proxy = None
        self.remotecall_obj_cache = dict()

    class _RemoteCall:
        def __init__(self, super, name):
            self.super = super
            self.name = name
            self.docstr = None
        def __call__(self, *varg, **kwarg):
            return self.super._call_method(self.name, *varg, **kwarg)

        def __getattr__(self,name):
            if name == '__doc__':
                return self.getdoc()
            else:
                raise AttributeError, name

        def _get_doc(self):
            try:    ret = self.super._get_docstring(self.name)
            except: ret = "<No documentation available>"
            return ret

        def getdoc(self):
            if self.docstr is None:
                self.docstr = self._get_doc()
            return self.docstr

    def __getattr__(self, name):
        cache = self.remotecall_obj_cache
        if name in cache:
            return cache[name]
        m = self._RemoteCall(self,name)
        cache[name] = m;
        return m
        # if not found:
        #    raise AttributeError, name

    def ensure_connection(self):
        """Perform a quick check that the Plotter has connected to the server.
        This basically just checks if an internal variable is set or not.
        So it might not do anything in the case that the server has died.
        This method doesn't actually ping the server.
        """
        if self.server_proxy is None:
            self._connect_to_server()
            if self.server_proxy is None:
                raise RuntimeError('Cannot connect to server')

    def _get_docstring(self, name):
        self.ensure_connection()
        ret = self.server_proxy.system.methodHelp(name)
        return ret

    def _call_method(self, name, *varg, **kwarg):
        self.ensure_connection()
        #print "Calling method " + name 
        #print "  with vargs: " + str(varg)
        #print "  and kwargs: " + str(kwarg)
        
        encode = common.marshall
        encode_kw = common.marshall_keywords
        bin_varg = [encode(a) for a in varg]
        #bin_kwarg = dict([(a,encode(b)) for a,b in kwarg.iteritems()])
        bin_kwarg = None
        if kwarg:
            bin_kwarg = encode_kw(kwarg)

        # presumably these are cached by the proxy in some 
        # intelligent way.  Thus we don't cache them here.
        func = getattr(self.server_proxy, name)

        def call_func(_kw,_arglist):
            #print "Calling with arglist: ", _arglist
            #print "             keywords: ", _kw
            if _kw:
                ret = func(_kw,*_arglist)
            else:
                ret = func(*_arglist)
            return ret

        try:
            ret = call_func(bin_kwarg,bin_varg)
        except socket.error:
            # maybe the server died?  Try to start a new one
            if not self._connect_to_server():
                # ok, maybe that wasn't it
                raise 
            else:
                # alright, try again
                ret = call_func(bin_kwarg,bin_varg)
        return ret

    def _start_local_server(self):
        """Start a local instance of the plot server process and return its pid"""
        return spawn_plotter()

    def _connect_to_server(self):
        print "Connecting to server...",
        version = None
        try:
            url = self.service_url
            self.server_proxy = xmlrpclib.ServerProxy(url,allow_none=True)
            version = self.server_proxy.version()
        except socket.error:
            # could be that the thing just hasn't been started
            # So try to start a local one ourselves
            import time
            try:
                pid = self._start_local_server()
                if pid:
                    self.server_proxy = xmlrpclib.ServerProxy(url,allow_none=True)
                    t = time.clock()
                    timeout = 10.0
                    response = None
                    # give it a moment
                    time.sleep(1)
                    while time.clock()-t < timeout:
                        try:
                            response = self.server_proxy.version()
                        except:
                            print 'waiting...',
                            time.sleep(1)
                        else:
                            version = response
                            break
                    if response is None:
                        raise RuntimeError('Unable to start/connect to server')
            except:
                # time to give up
                report_exception("Error starting server")
                self.server_proxy = None
                return False
        except:
            report_exception("Error connecting")
            raise
        print '\nconnected to', common.unmarshall(version)[0], "on", url
        return True

    def reconnect():
        """Force a reconnect to the server.
        Will start a server if none is found, or connect to one if 
        it exists already.
        """
        return _connect_to_server()



#if __name__=="__main__":
#  hmm could start some kind of interactive plotting shell here I suppose
