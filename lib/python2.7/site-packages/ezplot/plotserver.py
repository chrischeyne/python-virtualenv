# -*- coding: iso-8859-1 -*-
# plotting service server

import matplotlib
matplotlib.use('WXAgg')
matplotlib.interactive(True)
from matplotlib import pylab
import numpy
import sys

import  wx
from twisted.internet import wxreactor
wxreactor.install()
from twisted.internet import reactor, defer
from twisted.web import server, resource
from twisted.web import xmlrpc
#from twisted.web import soap 
import xmlrpclib
import pickle

from ezplot import common

#--------------------------------------------------
LogToWindow = True; # -> printing stdout/stderr to console, vs a wxWindow


#--------------------------------------------------
# Note: not all of these make sense, like isinteractive
# TODO: do some pruning/special handling
ALL_PYLAB_METHODS = \
                  ['acorr','annotate','arrow','axes','axhline','axvline',
                   'axhspan','axvspan','axis','bar','barh','broken_barh',
                   'box','boxplot','cla','clabel','clf','clim','close',
                   'colorbar','cohere','contour','contourf','csd','delaxes',
                   'draw','errorbar','figlegend','figimage','figtext',
                   'figure','fill','gca','gcf','gci','getp','grid','hist',
                   'hold','ioff','ion','isinteractive','imread','imshow',
                   'ishold','legend','loglog','matshow','pcolor','pcolormesh',
                   'pie','plot','plot_date','pie','polar','psd','quiver',
                   'rc','rgrids','savefig','scatter','setp','semilogx','semilogy',
                   'show','specgram','spy','stem','subplot','subplots_adjust',
                   'subplot_tool','table','text','thetagrids','title','xcorr',
                   'xlim','ylim','xticks','yticks','xlabel','ylabel','autumn',
                   'bone','cool','copper','flag','gray','hot','hsv','jet',
                   'pink','prism','spring','summer','winter','spectral']

#---------------------------------------------------------------------------
class PylabFuncWrapper:
    def __init__(self, funcname):
        self.fname = funcname
        self.funcptr = getattr(pylab,funcname)
        self.__doc__ = getattr(self.funcptr,'__doc__')

    def __call__(self, *varg,**kwarg):
        decode = common.unmarshall
        KWArgs  = common.KeywordArgs
        try:
            nu_varg = [decode(x) for x in varg]
            # xmlrpclib doesn't support keyword args, so we encode them 
            #nu_kwarg = dict([(k,decode(x)) for k,x in kwarg.iteritems()])
            nu_kwarg = dict()
            # is there a way to split a list into parts in one pass based on a predicate?
            kwargs = filter(lambda x: isinstance(x,KWArgs), nu_varg)
            nu_varg = filter(lambda x: not isinstance(x,KWArgs), nu_varg)
            for kwarg in kwargs:
                nu_kwarg.update(kwarg.dict)
            #print "nuvarg is :", nu_varg
            #print "kwarg is :", nu_kwarg
            self.funcptr( *nu_varg, **nu_kwarg )
        except:
            import traceback
            def formatExceptionInfo(maxTBlevel=5):
                cla, exc, trbk = sys.exc_info()
                excName = cla.__name__
                try:
                    excArgs = exc.__dict__["args"]
                except KeyError:
                    excArgs = "<no args>"
                excTb = traceback.format_tb(trbk, maxTBlevel)
                return (excName, excArgs, excTb)

            exinfo = formatExceptionInfo()
            print "Calling error: ", exinfo[0], ":", exinfo[1]
            print "traceback:\n", exinfo[2]

            return False
        return True


#----------------------------------------------------------------------------

def getAppImageData():
    return \
'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00 \x00\x00\x00 \x08\x06\x00\
\x00\x00szz\xf4\x00\x00\x00\x04sBIT\x08\x08\x08\x08|\x08d\x88\x00\x00\x04\tI\
DATX\x85\xdd\x97_L\x9bU\x18\xc6\x7f-m\x81\xb5R76\x084s\xba\xd4\xa1\xc2\x85\t\
\x0e\xc3*4\xce5\xc6L/p\x18\x17\xa611$F\x9d\x96\x0b\x13\xb92\x11\xa3\xd18\x8c\
\xcbb2tF\xd4\xb9L\x1cK\xc0%\x1bn\xe3\x02\x94\xa9\x1b\x16\x89t\x1b\x03\xf1\
\xc2d\xd5.\xb3\r+\xdd\xd7~\xed\xf1\xa2\xe7\xeb\x1fF\x8b\x96\xce\x0b\x9f\xe4\
\xa4\xedy\xbf\x9c\xe7y\xdf\xf7|\xa7\xe7\xd1\x91\t\x1d\xa0\x07\x0c@\x91\x1cz9\
\x9f/\x04\x10\x97C\x05bi\xbf3\x16.\x92\xc4%@)\xb0\n(\x96s\xf9\x8a\x10r\xa8\
\x80\x02\x84\xd3FT\x13\x81$(\x01\xca[ZZ^\x18\x1b\x1b\x9bT\x14%*\n\x04\x8f\
\xc73\xe7v\xbb{\x00\x07p\x17P!\x13,\xd2\xaa`\x04\xd6tvvv\x17\x8at)\x0c\x0c\
\x0c\xfc\x0cl\x07\xea\x80u\xb2\xc2\xe8\x00\xb3\xcdf\xbb_Q\x94\xc8\xcd\x14 \
\x84\x10.\x97k?\xf00`\x07\xca\xf4\xb2\xfc&\xa7\xd3\xe94\x99LF\xad\'\x9b_=\
\x93G\xcb\x97\x87\xcb\xe5\xda\x0cT\x01V\xa0X\xdb\\F\xab\xd5Z^H"u`\x90\x85\
\xa7\x9f!z\xa4?c\xdeb\xb1X\x81r\xc0\x02\x984\x01\x06\x12\xfb\xa0`\x88\x1c\
\xee\xa3\xb8\xa9\x91\xc8\x17_.\x0e\x19%y\t`\xd4\x04h\xad(\x0cT\x15\x04\x84\
\xbf\x1a\xc4\xf8\xc4\x8e\xc5Q\xed\x9c1\x00z\x83\x14\xb0\x92\x83\xe6\x06(\xfb\
?\x82\x8a\n,\x87>\x03\xfd\x92yi\x89\xeb\xd2\xa3y\x898\xfa\xfd\x15vuO\xd1?\
\xf6\x07\x00\xea\xc8(\x91\x13\')}\xfd\xb5l\xe4\x190\xfc\x13\x92\xd8\x87=\x88\
\t\x0f\xba\xda:\x8a^\xdc\x9d\x11\xeb\x1b\xbd\x8c\xab&\xce\xb7\xd3S\xfc4:\x85\
\xfb\xf8\xbb\\z\xee\x15&G\xff\xe4\xc4\x0f\xe7xr\xeb\xed\xb4=d\xcf\xbavN\x89_\
\x9fKd%<\x1e\x8a\x1e\xddN\xec\xc7\xb3\x88\xd9\xd9d|\xf2\xb7yB\xe1\x08\x03\
\x1e\x85\x06\xdb\x1dt\x9c\xfd\x84\x19\xc7#\x1c[X\xcd\xa7C\x17i\xae1rp\xe8b\
\xce\xe4\xb2W@\x08\x1e\xbb\xaf2\xf1\xbd\xb6\x96h_?TV\x12\xd9\xf3\x1e\x98W1\
\xb1\xe9\x01\xde\xbf\xba\x9e7\x9e\xb2s\xefF+\xd7\xdfz\x87\xb8\xad\x92-o\xbe\
\xcc\x16\xe0\xd0\x862>\x1f\xba\xc0.W\xf6\xec\x97\x15\x90|h\xf7K\xc9\xefjL0\
\xb8w\x90\x8d\xa7\xbf\xa1\'\xecC?QJpv\x0etz\xcaN\x1fO>\xd7\xb6\xcdN\xdb\xb6\
\xdc\xe4\x90\xa3\x05"M\x80\x86\xab\xd7\xa2t\x1c\xb8\x80\xb7\xfa\x1e\xee>\xb8\
\x0f\xf3\x9e\xb7\x89\xcd\xfcJ\xd9\xb3m\xc4C!t\xb7X\x96%\\\x8c\xac\x15\x10\
\xa4\x04\x1c=\xe3\xe7\xf0\xc8e"Q\x95\x9dM\x95\xect\xda\x12\x81Mwbp4\x12\xd8\
\xf71\xc6\xe6\xa6\x7fM\x9eS\x00"\xf9W\xcd\x91\xef|4\xdb\xe1\x94WM\x91K\x98\
\xf7vc\xce\x8b:\x81\xac-\x88\xa7\tx\xbcq-#\xd3\nm\xce\xea\x15P-\x8d\xec\x15\
\x88\xa7Z\xd0\xea\xa8\xa2\xd5QUpr\xc8\xb9\t\xe3\xd9B\xff?\x01Z\xad3\xde;\x11\
\xffo+p\xe3K\xbf\xc49P@h\xd7ra\x90\xe41\x9f\xcf\xe7\xcfxB\xc4\xa9{\xfe\x98<\
\x0f\x84\xdc\x94\xf2t\x10\xa9O\xa9vY\xc1\xe7\x0f\xb4\x02\xe0\xf7\xfb\xc3@\
\x84\x94G\xc0\x00\xac\xb3Z\xad[\x03\x81\xc0\xc2\xcd\xbe\x94\xd6\xd7\xd7\x0f\
\x01\x1d@3P\xad\x97\xa5\x88\x06\x83A_{{\xfb\x07\xe1pX]i}\xb3\xa1\xab\xabkf||\
\xfc\x17\xe0\n0\x0fD\xb4\xdbP)\xb0\x06\xb8\xad\xa6\xa6\xe6A\xb7\xdb\xbd\xa3\
\xa1\xa1a\x03)W\x04\xf9;#\xbc^\xef\xb5\xde\xde\xde\xe9\xe1\xe1a\x0fp\t8\x0f\
\xcc\x01~mQ#\t\xa7\xb2\x16\xb0\x01\xebI\\\x9dWKq\xda\xd5-\x1f\x011\x12\xb6,\
\x00\xf8\x80\xdf\xe5\xf0\x03\xf3\xda\xa2\xfa4\x11VI|+`&\xe1^VbPc$|`\x08\x08\
\x02\x7fI1!d\x0b4h\xb7U\x13)\x83j"\xb3\r\xf9@3\xa7\x11\xe0\xba\x1c\x8a\x9c\
\x8b/\xceJ\xdb\x13\xe9\xd6\xbc\x90\xf6<\xdd\x9a\x0b\x80\xbf\x01m#\xc0Zzd\xf4\
Z\x00\x00\x00\x00IEND\xaeB`\x82' 

def getAppImage():
    import cStringIO
    stream = cStringIO.StringIO(getAppImageData())
    return wx.ImageFromStream(stream)

def getAppBitmap():
    return wx.BitmapFromImage(getAppImage())

def getAppIcon():
    icon = wx.EmptyIcon()
    icon.CopyFromBitmap(getAppBitmap())
    return icon

#----------------------------------------------------------------------------
class LogPanel(wx.TextCtrl):
    def __init__ (self,parent):
        import time
        self.parent = parent

        mystyle = wx.TE_MULTILINE|wx.TE_READONLY
        #mystyle |= wx.HSCROLL
        wx.TextCtrl.__init__(self,self.parent,size=wx.DefaultSize, style=mystyle)

        sys.stdout = self
        sys.stderr = self

#---------------------------------------------------------------------------
class MainFrame(wx.Frame):
    def __init__(self, parent, ID, title, pos=wx.DefaultPosition,
                 size=(250,170), style=wx.DEFAULT_FRAME_STYLE):

        wx.Frame.__init__(self, parent, ID, title, pos, size, style)
        
        icon = getAppIcon()
        self.SetIcon(icon)

        self.CreateStatusBar()

        panel = wx.Panel(self, -1)
        
        sizer = wx.BoxSizer(wx.VERTICAL)

        if LogToWindow or not sys.stdout.isatty():
            label = wx.StaticText(panel, -1, "Stdout/stderr output:")
            log = LogPanel(panel)
            sizer.Add(label,0,wx.EXPAND)
            sizer.Add(log,1,wx.EXPAND)
            sizer.Add((5, 5), 0, wx.EXPAND) #  a bit of a gap space
        else:
            sizer.Add((5, 5), 1, wx.EXPAND) #  make button go to bottom

        button = wx.Button(panel, 1003, "E&xit Server")
        button.SetDefault()

        sizer.Add(button,0,wx.ALIGN_BOTTOM|wx.ALIGN_RIGHT);

        panel.SetSizer(sizer)

        self.Bind(wx.EVT_BUTTON, self.OnStopMe, button)
        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroyWindow)

    def OnStopMe(self, event):
        self.Close(True)

    def OnCloseWindow(self, event):
        self.Destroy()

    def OnDestroyWindow(self, event):
        reactor.stop()
        wx.Exit()



#----------------------------------------------------------------------------
class PlotServerApp(wx.App, xmlrpc.XMLRPC): #soap.SOAPPublisher

    # the wx related startup code, building the gui
    def OnInit(self):
        self.frame = MainFrame(None, -1, 'Matplotlib Plot Server')
        self.frame.Show(True)
        self.SetTopWindow(self.frame)
        self.allowNone = True

        # Was needed for addIntrospection... not sure why
        self.subHandlers = dict()

        from time import ctime
        print "Welcome to ezplot version %s." % common.__version__
        print "Using matplotlib version %s." % matplotlib.__version__
        print "Started %s." % ctime()

        self.init_pylab_methods()

        mprefix = "xmlrpc_"
        setattr(self, mprefix + "exit", self.do_exit);
        setattr(self, mprefix + "version", self.do_version);
        setattr(self, mprefix + "echo", self.do_echo);

        return True

    # initialize XML-RPC functions
    def init_pylab_methods(self):
        """Sets up all the pylab functions supported by the server"""

        methods = ALL_PYLAB_METHODS
        for f in methods:
            try:
                func = PylabFuncWrapper(f)
                #func.useKeywords = True
                #setattr(self, 'soap_'+f, func)
                setattr(self, 'xmlrpc_'+f, PylabFuncWrapper(f))
            except KeyboardInterrupt:
                raise
            except:
                # I guess this version of mpl doesn't know this one...
                print "Matplotlib function '%s' not found." % f
                pass

    def do_exit(self):
        """Stops the server and exits."""
        self.frame.Close() # Sending closing event
        return 'Shutdown initiated'

    def do_echo(self, x):
        return x

    def do_version(self):
        ver = common.version_tuple
        qual = common.version_qualifier
        ver_string = "plotserver " + ".".join([str(x) for x in ver]) + qual
        return (ver_string, ver)

    #def soap_deferred(self):
    #    return defer.succeed(2)


def start():
    # Initiliaze MyApp
    app = PlotServerApp(False)
    
    # Make wx application twisted aware
    # Have to run "wxreactor.install()" on top before
    reactor.registerWxApp(app)

    # Make a XML-RPC Server listening on a port
    port = common.defaultPort
    
    # Add introspection so doc strings will show up on client side
    # (TODO: Adding introspection doesn't seem to work)
    xmlrpc.addIntrospection(app)

    root =  resource.Resource()
    root.putChild('RPC2', app)
    #root.putChild('SOAP', app)

    # TODO: make it possible to pass in the interface to use, rather than
    # restricting it unconditionally to localhost
    reactor.listenTCP(port, server.Site(root), interface='127.0.0.1')

    # Start both reactor parts (wx MainLoop and XML-RPC server)
    reactor.run()

    # restore stdout/stderr
    sys.stdout = sys.__stdout__
    sys.stderr = sys.__stderr__
    

if __name__ == '__main__':
    start()
    
